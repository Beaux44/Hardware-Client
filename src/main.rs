#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] use eframe::CreationContext;
use eframe::egui;
use egui::FontFamily::Proportional;
use egui::FontId;
use egui::TextStyle::*;
use message_io::network::Endpoint;
use message_io::node::NodeHandler;
use message_io::node::NodeListener;
use sysinfo::{System, SystemExt, CpuExt, DiskExt, Disk};
use std::{time::Duration};
use serde::{Serialize, Deserialize,};
use message_io::node::{self, NodeEvent};
use message_io::network::{NetEvent, Transport};
use std::thread;


#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "kebab-case")]
struct DiskData {
    disk_name: String,
    disk_total: f32,
    disk_available: f32
}
// TODO, add disk percent
impl DiskData {
    fn new(disk: &Disk) -> DiskData {
        DiskData {
            disk_name: disk.mount_point().to_str().unwrap().to_owned(),
            disk_total: (disk.total_space() as f32 / 1_073_741_824f32).ceil(),
            disk_available: (disk.available_space() as f32 / 1_073_741_824 as f32).ceil()
        }
    }
    
    fn build(sys: &System) -> Vec<DiskData> {
        sys.disks().iter()
                   .map(|d| DiskData::new(d))
                   .collect()
    }
}
// TODO Add ram percent
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "kebab-case")]
struct Hardware {
    cpu_type: String,
    cpu_count: i32,
    cpu_usage: f32,
    ram_total: f32,
    ram_usage: f32,
    disks: Vec<DiskData>
}

impl Hardware {
    fn new(sys: &System) -> Hardware {
        Hardware { 
            cpu_type: sys.global_cpu_info().brand().trim().to_owned(), 
            cpu_count: sys.cpus().len() as i32, 
            cpu_usage: (sys.cpus().iter().map(|c| c.cpu_usage()).sum::<f32>() / sys.cpus().len() as f32).ceil(),
            ram_total: (sys.total_memory() as f32 / 1_073_741_824 as f32).ceil(), 
            ram_usage: (sys.used_memory() as f32 / 1_073_741_824 as f32), 
            disks: DiskData::build(&sys)
        }
    }
}

enum Signal {
    SendData,
    Disconnect
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "event", rename_all = "SCREAMING-KEBAB-CASE")]
enum Event {
    #[serde(rename_all = "kebab-case")]
    Connect { client_type: String, client_name: String }, 
    #[serde(rename_all = "kebab-case")]
    Disconnect { client_type: String, client_name: String }, 
    HardwareData(Hardware)
}


fn websocket(server:Endpoint, handler:NodeHandler<Signal>, listener:Option<NodeListener<Signal>>) {
    thread::spawn(move || {
        let init_connect = Event::Connect { 
            client_type: "SERVICE".to_string(), 
            client_name: "Server".to_string()
        };
        let mut sys = System::new_all();    
        listener.unwrap().for_each(move |event| match event {
            NodeEvent::Network(net_event) => match net_event {
                NetEvent::Connected(_endpoint, _ok) => {
                    // Send connect event
                    handler.network().send(server, serde_json::to_string(&init_connect).unwrap().as_bytes());
                },
                NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
                NetEvent::Message(_endpoint, data) => {
                    println!("Received: {}", String::from_utf8_lossy(data));
                    // If signal requests hardware status
                    handler.signals().send(Signal::SendData)
                    // If signal requests hardware data termination
                    // --> TODO stop SendData signal? how to cancel hander.signals()send_with_timer?
                },
                NetEvent::Disconnected(_endpoint) => (),
            }
            NodeEvent::Signal(signal) => match signal {
                Signal::SendData => {
                    sys.refresh_all();
                    let hw = Hardware::new(&sys);
                        handler.signals().send_with_timer(Signal::SendData, Duration::from_secs(1));
                        handler.network().send(server, serde_json::to_string(&Event::HardwareData(hw)).unwrap().as_bytes());

                }
                Signal::Disconnect => {
                    let disconnect = Event::Disconnect { 
                        client_type: "SERVICE".to_string(), 
                        client_name: "Server".to_string()
                    };
                    handler.network().send(server, serde_json::to_string(&disconnect).unwrap().as_bytes());
                    handler.stop()
                }
            }
        });
    });
}


fn main() -> Result<(), eframe::Error> {
    // Log to stdout (if you run with `RUST_LOG=debug`).
    tracing_subscriber::fmt::init();

    let options = eframe::NativeOptions {
        initial_window_size: Some(egui::vec2(650.0, 240.0)),
        ..Default::default()
    };
    eframe::run_native(
        "Hardware Client",
        options,
        Box::new(|ctx| Box::new(MyApp::new(ctx))),
    )
}

struct MyApp {
    ip: String,
    freq: u32,
    connected: bool,
    handler: NodeHandler<Signal>,
    listener: Option<NodeListener<Signal>>
}

impl MyApp {
    fn new(_ctx: &CreationContext) -> Self {
        let (handler, listener) = node::split();
        Self {
            ip: "192.168.1.138".to_owned(),
            freq: 1,
            connected: false,
            handler,
            listener: Some(listener)
        }
    }
    fn re_init(&mut self) {
        let (handler, listener) = node::split();
        self.handler = handler;
        self.listener = Some(listener);
      }
}

impl eframe::App for MyApp {
    
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
        let mut style = (*ctx.style()).clone();
        // Redefine text_styles
        style.text_styles = [
            (Heading, FontId::new(30.0, Proportional)),
            (Name("Heading2".into()), FontId::new(25.0, Proportional)),
            (Name("Context".into()), FontId::new(20.0, Proportional)),
            (Body, FontId::new(18.0, Proportional)),
            (Monospace, FontId::new(14.0, Proportional)),
            (Button, FontId::new(14.0, Proportional)),
            (Small, FontId::new(10.0, Proportional)),
        ].into();
        // Mutate global style with above changes
        ctx.set_style(style);

            ui.heading("Hardware Client Connection");
            ui.horizontal(|ui| {
                let ip_label = ui.label("Server IP: ");
                ui.text_edit_singleline(&mut self.ip)
                    .labelled_by(ip_label.id);
            });
            ui.horizontal(|ui| {
                let _ip_label = ui.label("Send Frequency (Seconds): ");
                ui.add(egui::Slider::new(&mut self.freq, 0..=120));

            });

            if self.connected == false {
                let button = ui.add_sized([120., 40.], egui::Button::new("Connect"));
                if button.clicked() {
                    let server = match self.handler.network().connect_sync(Transport::Ws, format!("ws://{}:8081/ws/stats", self.ip)) {
                        Ok((server, _)) => server,
                        Err(_) => {
                            println!("Errored");
                            panic!("Bad Endpoint");
                          }
                    };

                    websocket(server, self.handler.clone(), self.listener.take());
                    self.connected = true;
                    println!("ip: {} freq: {} connected: {}", self.ip, self.freq, self.connected);
            }
            } else {
                let button = ui.add_sized([120., 40.], egui::Button::new("Disconnect"));
                if button.clicked() {
                    self.handler.signals().send(Signal::Disconnect);
                    self.connected = false;
                    self.re_init();
                    println!("ip: {} freq: {} connected: {}", self.ip, self.freq, self.connected);
                }
            }
        });
    }
}